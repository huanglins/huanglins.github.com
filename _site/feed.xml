<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tnecniV</title>
    <description>// iOS Developer，也写Android和python。正在学习全栈。很高兴认识你。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 28 Aug 2017 11:51:24 +0800</pubDate>
    <lastBuildDate>Mon, 28 Aug 2017 11:51:24 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>CentOS 防火墙配置之 iptables和DDoS deflate</title>
        <description>&lt;h2 id=&quot;iptables&quot;&gt;iptables&lt;/h2&gt;
&lt;p&gt;netfilter/iptables IP 信息包过滤系统是一种功能强大的工具，可用于添加、编辑和除去规则，这些规则是在做信息包过滤决定时，防火墙所遵循和组成的规则。这些规则存储在专用的信息包过滤表中，而这些表集成在 Linux 内核中。在信息包过滤表中，规则被分组放在我们所谓的链（chain）中。&lt;/p&gt;

&lt;p&gt;netfilter 组件也称为内核空间（kernelspace），是内核的一部分，由一些信息包过滤表组成，这些表包含内核用来控制信息包过滤处理的规则集。
iptables 建立在 netfilter 架构基础上的一个包过滤管理工具，也称为用户空间（userspace），它使插入、修改和除去信息包过滤表中的规则变得容易。
iptables包含4个表，5个链。其中表是按照对数据包的操作区分的，链是按照不同的Hook点来区分的，表和链实际上是netfilter的两个维度。&lt;/p&gt;

&lt;h4 id=&quot;iptables-&quot;&gt;1.iptables 语法规则&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables [-t 表] 大写选项子命令(-A) [规则号] 链名 匹配标准(-s xx.xx.xx.xx) -j 目标（规则）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：所有表名必须小写，命令动作必须大写，链名必须大写，匹配标准必须小写，目标规则必须大写&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;iptables--1&quot;&gt;2.iptables 表&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;filter&lt;/td&gt;
      &lt;td&gt;一般的数据包过滤功能&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;nat&lt;/td&gt;
      &lt;td&gt;用于nat(网络地址转换)功能（端口映射，地址映射等）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mangle&lt;/td&gt;
      &lt;td&gt;用于对特定数据包进行修改&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;raw&lt;/td&gt;
      &lt;td&gt;优先级最高，设置raw时一般是为了不再让iptables做数据包的链接跟踪处理，提高性能&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;表的处理优先级：raw &amp;gt; mangle &amp;gt; nat &amp;gt; filter&lt;/p&gt;

&lt;h4 id=&quot;iptables--2&quot;&gt;3.iptables 链&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;PREROUTING&lt;/td&gt;
      &lt;td&gt;数据包进入路由表之前&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;INPUT&lt;/td&gt;
      &lt;td&gt;通过路由表后目的地为本机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;FORWARDING&lt;/td&gt;
      &lt;td&gt;通过路由表后，目的地不为本机&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OUTPUT&lt;/td&gt;
      &lt;td&gt;由本机产生，向外转发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POSTROUTIONG&lt;/td&gt;
      &lt;td&gt;发送到网卡之前。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如图：
&lt;img src=&quot;/img/p-iptables/iptables_chain.png&quot; alt=&quot;&quot; /&gt;
iptables 中表和链的对应关系如下：
&lt;img src=&quot;/img/p-iptables/iptables_chain1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;表&lt;/th&gt;
      &lt;th&gt;包含的规则链&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;filter&lt;/td&gt;
      &lt;td&gt;INPUT , FORWARD , OUTPUT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;nat&lt;/td&gt;
      &lt;td&gt;PREROUTING , OUTPUT , POSTROUTING&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;mangle&lt;/td&gt;
      &lt;td&gt;PREROUTING , OUTPUT , POSTROUTING&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;iptables--3&quot;&gt;4.iptables 相关参数&lt;/h4&gt;

&lt;h5 id=&quot;section&quot;&gt;4.1.命令参数&lt;/h5&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-A&lt;/td&gt;
      &lt;td&gt;向规则链中添加一条规则，默认被添加到末尾&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-I&lt;/td&gt;
      &lt;td&gt;插入一条规则，默认会被插入到首部&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-T&lt;/td&gt;
      &lt;td&gt;指定要操作的表，默认是 &lt;em&gt;filter&lt;/em&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-D&lt;/td&gt;
      &lt;td&gt;从规则链中删除规则，可以指定序号或者匹配的规则来删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-R&lt;/td&gt;
      &lt;td&gt;进行规则替换&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-F&lt;/td&gt;
      &lt;td&gt;清空所选的链，重启后恢复&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-N&lt;/td&gt;
      &lt;td&gt;新建用户自定义规则链&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-X&lt;/td&gt;
      &lt;td&gt;删除用户自定义的规则链&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;section-1&quot;&gt;4.2.匹配标准参数&lt;/h5&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-p&lt;/td&gt;
      &lt;td&gt;用来指定协议。可以是 tcp，udp，icmp等，也可以是数字的协议号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-s&lt;/td&gt;
      &lt;td&gt;指定源地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;指定目的地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-i&lt;/td&gt;
      &lt;td&gt;进入接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-o&lt;/td&gt;
      &lt;td&gt;流出接口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–sport&lt;/td&gt;
      &lt;td&gt;源端口&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;–dport&lt;/td&gt;
      &lt;td&gt;目的端口，端口必须和协议一起来配合使用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;section-2&quot;&gt;4.3.目标规则&lt;/h5&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-j&lt;/td&gt;
      &lt;td&gt;采取的动作。ACCEPT(接收)，DROP(丢弃)，REJECT(拒绝)，&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;RETURN(返回主键继续匹配)，REDIRECT(端口重定向)，&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;MASQUERADE(地址伪装)，DNAT(目标地址转换)，SNAT(源地址转换)，MARK(打标签)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;iptables--4&quot;&gt;5.iptables 实际操作&lt;/h4&gt;

&lt;p&gt;以上是 iptables 语法规则的相关参数和说明，现在让我们来实际操作使用一下。一般常用操作的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;表， &lt;code class=&quot;highlighter-rouge&quot;&gt;mangle&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;raw&lt;/code&gt; 请自行 google 高级用法。&lt;/p&gt;

&lt;h5 id=&quot;section-3&quot;&gt;5.1.基本使用&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;列出 iptables 规则
# iptables -L		# 默认选择 filter 表
# iptables -t nat -L

清除 内置规则
# iptables -F
# iptables -t nat -F

清除自定义规则
# iptables -X
# iptables -t nat -F 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;filter&quot;&gt;5.2.filter&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;禁止某个IP访问
# iptables -I INPUT -s xxx.xxx.xx.x -j DROP

服务器禁止被 ping
# iptables -A INPUT -p icmp -j DROP
禁止某个 IP ping 服务器
# iptables -A INPUT -p icmp -s xxx.xxx.xx.x -j DROP
只允许某个 IP ping 服务器
# iptables -I INPUT -p icmp -s xxx.xxx.xx.x -j ACCEPT

开启端口服务
# iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT
# iptables -A INPUT -p udp -i eth0 --sport 53 -j ACCEPT

开启转发功能
- 普通转发，假设 eth0 连接内网，eth1 连接公网。(必须要有2块网卡)
# iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT
- 只允许已建连接以及相关连接对内转发
# iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT
- 允许对外转发
# iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT

允许 loopback 回环通讯
# iptables -A INPUT -i lo -p all -j ACCEPT
# iptables -A OUTPUT -o lo -p all -j ACCEPT

实例：当总连接数超过100时，启用 litmit/minute 限制
# iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT
- litmit 25/minute 每分钟限制最大连接数为25
- litmit-burst 100 当总连接数超过100时，启动 limit/minute 限制
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;nat&quot;&gt;5.3 nat&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;目的地址转换，映射内部地址
# iptables -t nat -A PREROUTING -i ppp0 -p tcp --dprot 81 -j DNAT --to 192.168.0.2:80
# iptables -t nat -A PREROUTING -i ppp0 -p tcp --dprot 81 -j DNAT --to 192.168.0.1-192.168.0.10

源地址转换，隐藏内部地址
# iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to 1.1.1.1
# iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to 1.1.1.1-1.1.1.10

地址伪装，动态ip的NAT（地址转换）
# iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j MASQUERADE
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;masquerade&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;snat&lt;/code&gt; 的主要区别在于，snat 是把源地址转换为固定的 IP 地址或者是地址池，而 masquerade 在 adsl 等方式拨号上网时候非常有用，因为是拨号上网所以网卡的外网IP经常变化，这样在进行地址转换的时候就要在每次都要修改转换策略里面的 ip，使用 masquerade 就很好的解决了这个问题，他会自己去探测外网卡获得的ip地址然后自动进行地址转换，这样就算外网获得的 ip 经常变化也不用人工干预了。&lt;/p&gt;

&lt;h5 id=&quot;section-4&quot;&gt;5.4 删除规则&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iptables -D chain rulenum [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;chain 是链的意思，就是 INPUT FORWARD 之类的定语，rulenum 是该条规则的编号，从1开始。可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;iptables -L INPUT --line&lt;/code&gt;列出指定的链的规则的编号来。然后通过编号删除
&lt;code class=&quot;highlighter-rouge&quot;&gt;
iptables -D INPUT 1
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;第二种办法是 &lt;code class=&quot;highlighter-rouge&quot;&gt;-A&lt;/code&gt; 命令的映射，不过用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-D&lt;/code&gt; 替换 &lt;code class=&quot;highlighter-rouge&quot;&gt;-A&lt;/code&gt; 。当你的链中规则很复杂，而你不想计算它们的编号的时候这就十分有用了。
也就是说，你如何一开始时用 &lt;code class=&quot;highlighter-rouge&quot;&gt;iptables -A.... &lt;/code&gt;语句定义了一个规则，那么删除此条规则时直接用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-D&lt;/code&gt; 来代替 &lt;code class=&quot;highlighter-rouge&quot;&gt;-A&lt;/code&gt;， 其余的都不变即可，而不需要什么编号了。&lt;/p&gt;

&lt;h2 id=&quot;ddos-deflate&quot;&gt;DDoS deflate&lt;/h2&gt;
&lt;p&gt;DDos deflate 是一款免费的用来防御和减轻 DDos 攻击的脚本。它通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;netstat&lt;/code&gt; 监测跟踪与服务器创建了大量网络连接的IP地址，在监测到某个节点超过预设的限制时，该程序会通过 APF 或者 iptables 对这些 IP 进行一段时间内的禁止访问。&lt;/p&gt;

&lt;p&gt;DDoS deflate官方网站：&lt;a href=&quot;http://deflate.medialayer.com/&quot;&gt;http://deflate.medialayer.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何确定是否受到DDoS攻击了呢?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;执行 &lt;em&gt;netstat&lt;/em&gt; 命令
&lt;code class=&quot;highlighter-rouge&quot;&gt;
netstat -ntu | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -n
&lt;/code&gt;
或者
&lt;code class=&quot;highlighter-rouge&quot;&gt;
netstat -ntu | awk '{print $5}' | cut -d: -f1 | sed -n '/[0-9]/p' | sort |
 uniq -c | sort -nr
&lt;/code&gt;
下一段会过滤掉其中不是 IP 的一些记录，结果如下：
&lt;img src=&quot;/img/p-iptables/netstat_result.png&quot; alt=&quot;&quot; /&gt;
第一个表示每个IP当前的连接数，一般IP几十个以内都算比较正常。如果突然某个IP的连接数有成百上千个，那肯定就不正常了。&lt;/p&gt;

&lt;h4 id=&quot;ddos-deflate-1&quot;&gt;1.安装 DDoS deflate&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cd /tmp
# wget http://www.inetbase.com/scripts/ddos/install.sh
# chmod 0700 install.sh
# ./install.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;分别是：1.下载文件，2.给文件添加权限，3.执行安装 &lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;ddos-deflate-2&quot;&gt;2.配置 DDoS deflate&lt;/h4&gt;

&lt;p&gt;文件安装目录位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/ddos&lt;/code&gt;，其中文件有：
* &lt;strong&gt;ddos.conf&lt;/strong&gt;     	// 相关配置文件
* &lt;strong&gt;ssos.sh&lt;/strong&gt;		  		// shell脚本
* &lt;strong&gt;ignore.ip.list&lt;/strong&gt;	// ip白名单
* &lt;strong&gt;LICENSE&lt;/strong&gt;				// 许可&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ddos.conf&lt;/code&gt; 配置如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;##### Paths of the script and other files
PROGDIR=&quot;/usr/local/ddos&quot;
PROG=&quot;/usr/local/ddos/ddos.sh&quot;
IGNORE_IP_LIST=&quot;/usr/local/ddos/ignore.ip.list&quot; # ip 地址白名单
CRON=&quot;/etc/cron.d/ddos.cron&quot;	# 定时任务位置
APF=&quot;/etc/apf/apf&quot;		# APF
IPT=&quot;/sbin/iptables&quot;		# iptables

##### frequency in minutes for running the script
##### Caution: Every time this setting is changed, run the script with --cron
#####          option so that the new frequency takes effect
FREQ=1		# 检测时间间隔，默认为1分钟

##### How many connections define a bad IP? Indicate that below.
NO_OF_CONNECTIONS=150		# 一个IP下的最大连接数,超过就会屏蔽

##### APF_BAN=1 (Make sure your APF version is atleast 0.96)
##### APF_BAN=0 (Uses iptables for banning ips instead of APF)
APF_BAN=0	# 使用 APF还是iptables，推荐使用 iptables，将APF_BAN 改为0即可。
# APF 是基于 iptables 的防火墙

##### KILL=0 (Bad IPs are'nt banned, good for interactive execution of script)
##### KILL=1 (Recommended setting)
KILL=1		# 是否屏蔽禁止IP，默认。

##### An email is sent to the following address when an IP is banned.
##### Blank would suppress sending of mails
EMAIL_TO=&quot;1@vincents.cn&quot;	# 当IP被屏蔽时给指定邮箱发送邮件。

##### Number of seconds the banned ip should remain in blacklist.
BAN_PERIOD=600			# 禁用IP时长,默认为600秒
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ddos.sh&lt;/code&gt; 中，可以将第 117 行的内容修改为，就是上面那句 &lt;em&gt;netstat&lt;/em&gt; 命令：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
netstat -ntu | awk '{print $5}' | cut -d: -f1 | sed -n '/[0-9]/p' | sort |
 uniq -c | sort -nr
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有文件内容更改后，执行：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
# sh /usr/local/ddos/ddos.sh
&lt;/code&gt;
会在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/cron.d/&lt;/code&gt;目录下生成一个定时任务&lt;code class=&quot;highlighter-rouge&quot;&gt;ddos.cron&lt;/code&gt;。内容为：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
0-59/1 * * * * root /usr/local/ddos/ddos.sh &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
&lt;/code&gt;
#### 3.测试&lt;/p&gt;

&lt;p&gt;接下来你就可以使用压力测软件 &lt;a href=&quot;/2017/03/28/web-pressure-test/&quot;&gt;webbench,Siege&lt;/a&gt; 来进行测试实验了。我的测试结果如下， 通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;webbench&lt;/code&gt; 开启压力测试后，IP就立即被封禁，且很快就收到邮件,效果还是非常明显的。
&lt;img src=&quot;/img/p-iptables/ddos_result.png&quot; alt=&quot;&quot; /&gt;
ps: 为了让图片少占点位置，只有这么拼接一下了。将就看。。。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;参考学习&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/argb/p/3535179.html&quot;&gt;iptabls&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.liusuping.com/ubuntu-linux/iptables-firewall-setting.html&quot;&gt;iptabls配置详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.linuxidc.com/Linux/2012-08/67505.htm&quot;&gt;iptables四个表与五个链间的处理关系&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yq.aliyun.com/ziliao/116528?spm=5176.8246799.0.0.JIvrMb&quot;&gt;Shell实现的iptables管理脚本&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.vpser.net/security/ddos-deflate.html&quot;&gt;DDoS deflate - Linux下防御/减轻DDOS攻击&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Sat, 26 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/26/iptables_ddos-deflate/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/26/iptables_ddos-deflate/</guid>
        
        <category>CentOS</category>
        
        <category>Web服务器</category>
        
        
      </item>
    
      <item>
        <title>Charles 抓取HTTPS数据包</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;Charles&lt;/a&gt; 是一款在Mac下常用的网络封包截取工具。Charles 可以将自己设置为系统的网络代理服务器，使得所有的网络请求都通过它来完成。这样，方便自己开发的时候进行接口调试和已经调试别的APP网络接口。。。&lt;/p&gt;

&lt;h2 id=&quot;http&quot;&gt;启用HTTP代理&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/p-charles/charles-set.png&quot; alt=&quot;&quot; /&gt;
这里启用 Charles 的代理，设置代理IP 为 &lt;code class=&quot;highlighter-rouge&quot;&gt;8888&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开终端输入 ifconfig 查看当前的局域网IP&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ifconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/img/p-charles/ifconfig.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后将手机连入同一个Wi-Fi, 在Wi-Fi的 HTTP代理中设置为电脑的IP地址和端口。&lt;/p&gt;

&lt;p&gt;Charles弹出确认框，点击Allow按钮即就可以愉快的获取到数据包信息啦。&lt;/p&gt;

&lt;h2 id=&quot;https&quot;&gt;如何使用HTTPS代理&lt;/h2&gt;

&lt;h4 id=&quot;section-1&quot;&gt;电脑端设置&lt;/h4&gt;

&lt;p&gt;想要抓取https的包的话，需要使用Charles自己的CA证书并进行
&lt;img src=&quot;/img/p-charles/charles-https-set.png&quot; alt=&quot;&quot; /&gt;
打开钥匙串，点击证书详情，设置为始终信任
&lt;img src=&quot;/img/p-charles/chain-set.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;手机端设置&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/p-charles/charles-https-set-ios.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果你已经将手机的网络代理设置 Charles，那么可以直接在浏览器中输入网址 &lt;code class=&quot;highlighter-rouge&quot;&gt;charlesproxy.com/getssl&lt;/code&gt; ,会提示安装证书描述文件:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/p-charles/iphone-profile.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;安装证书
点击安装即可，如果出现的不是这个界面，那么把链接换成 https://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/，点击安装 itself 后面的 here 就可以了。&lt;/p&gt;

&lt;p&gt;设置监听端口&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/p-charles/charles-https-set2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里是设置所有的地址的 443 端口都进行代理。如果只抓取部分，也可以进行单独的地址设置。&lt;/p&gt;

&lt;p&gt;现在就可以愉快的玩耍啦~ 以知乎为例&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/p-charles/charles-https-result-zhihu.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;参考学习&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/network-packet-analysis-tool-charles&quot;&gt;iOS开发工具——网络封包分析工具Charles&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/chenlogin/p/5849471.html&quot;&gt;charles https抓包&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Wed, 09 Aug 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/08/09/charles-https-proxy/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/08/09/charles-https-proxy/</guid>
        
        <category>macOS</category>
        
        
      </item>
    
      <item>
        <title>CentOS LAMP/LEMP 等各种服务环境搭建</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;由于之前捣鼓学习一些东西所作的笔记等都存放在印象笔记中，比较分散和杂乱。加上又准备更新自己的博客，
于是将折腾阿里云服务器整理出来，这篇会持续更新。(&lt;em&gt;^__^&lt;/em&gt;)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;l---linux--&quot;&gt;L - Linux &amp;gt; 一台云服务器&lt;/h2&gt;

&lt;p&gt;首先你得有一台云服务器。常用的云服务提供商有，&lt;code class=&quot;highlighter-rouge&quot;&gt;阿里云&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;腾讯云&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;亚马逊 AWS&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;微软 Azure&lt;/code&gt;等。
但是在国内的话，个人还是比较推荐阿里云。最低配一个月60块钱的样子。&lt;/p&gt;

&lt;p&gt;购买后阿里云会给你分配一个云服务器的公网IP地址。通过 SSH 连接云服务器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh root@xxx.xxx.xxx.xxx

输入密码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;yum&quot;&gt;yum&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过 yum 命令我们可以很方便的安装管理例如 mysql，php等常用的软件包服务。&lt;/p&gt;

&lt;p&gt;yum 命令格式为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum [options] [command] [package ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section&quot;&gt;更新源&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum update

yum upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;a---apache---httpd&quot;&gt;A - Apache -&amp;gt; httpd&lt;/h2&gt;

&lt;p&gt;Apache 在Linux系统中，叫 &lt;strong&gt;httpd&lt;/strong&gt;。O__O “…&lt;/p&gt;

&lt;h4 id=&quot;apache&quot;&gt;安装 Apache&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install httpd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 启动Apache&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl start httpd.service 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这时在浏览器中输入IP地址，你可以看到Apache的Test页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 关闭Apache&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl stop httpd.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 设置Apache开启自动启动&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl enable httpd.service 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;Apache 在CentOS中默认的根目录在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/www/html&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Apache 相关的配置文件目录在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/httpd/conf/httpd.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其他相关的配置文件目录在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/httpd/conf.d/&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;j---java&quot;&gt;J - Java&lt;/h2&gt;

&lt;p&gt;查看可用的 JDK软件包列表:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum search java | grep -i --color JDK
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装 java-jdk&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install java-1.8.0-openjdk  java-1.8.0-openjdk-devel  #安装openjdk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看当前 java 版本&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -version     #查看java版本
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;java 存放的地址  &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/jvm&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;java-&quot;&gt;配置 Java 环境变量&lt;/h4&gt;

&lt;p&gt;将 jdk 拷贝到 /usr/local/java 目录下。没有的话 &lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir&lt;/code&gt;创建，统一放到 /usr/local 目录下便于管理。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/lib/jvm

cp -R java-1.8.0-openjdk /usr/local/java/jdk1.8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;section-2&quot;&gt;配置环境变量&lt;/h6&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将下面内容添加到文件末尾，for循环后面。这里直接引用 /usr/lib/jvm 目录下的 JDK也是可以的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export JAVA_HOME=/usr/local/java/jdk1.8
export PATH=$JAVA_HOME/bin:$PATH:
export JAVA_BIN=$JAVA_HOME/bin
export CLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar
export JAVA_HOME JAVA_BIN PATH CLASSPAT
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;让配置立即生效&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检查环境变量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# echo $JAVA_HOME

-&amp;gt; /usr/local/java/jdk1.8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;t---tomcat&quot;&gt;T - Tomcat&lt;/h2&gt;

&lt;p&gt;Tomcat 官网 : &lt;a href=&quot;http://tomcat.apache.org/&quot;&gt;http://tomcat.apache.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;选择一个版本的 tar.gz 文件进行下载&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# wget http://ftp.cuhk.edu.hk/pub/packages/apache.org/tomcat/tomcat-6/v6.0.51/bin/apache-tomcat-6.0.51.tar.gz

# tar -zxvf apache-tomcat-6.0.51.tar.gz   # 解压

拷贝 tomcat 到 /usr/local 目录下

# cp -R apache-tomcat-6.0.51 /usr/local/tomcat7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;启动Tomcat&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/local/tomcat7/bin

sh startup.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;停止Tomcat&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sh shutdown.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;m---mysql---mariadb&quot;&gt;M - MySQL -&amp;gt; MariaDB&lt;/h2&gt;

&lt;p&gt;MySQL本身是开源免费的，但是在Mysql被Oracle收购后，有将MySQL闭源的风险。MariaDB是MySQL源代码的一个分支，是由MySQL的创始人麦克尔·维德纽斯主导开发，使用这些分支避免这个潜在的风险。&lt;/p&gt;

&lt;p&gt;详细的一些区别参考这篇：&lt;a href=&quot;http://bijian1013.iteye.com/blog/2315665&quot;&gt;浅谈MySQL和mariadb区别&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;gt;&lt;/em&gt; centOS 7 以后，软件源中默认的是MariaDB 而不是MySQL&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 安装 MariaDB&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install mariadb-server -y
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 启动 MariaDB&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl start mariadb.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 停止 MariaDB&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl stop mariadb.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 设置开启自动启动&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl enable mariadb.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;进入MySQL，第一次进入不用密码需要自己修改&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@VM_140_194_centos ~]# mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/img/p-centos-lnmp/mysql-login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 修改MySQL密码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql_secure_installation
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据提示进行设置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 创建用户以及分配权限&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 创建用户
CREATE USER 'vincent'@'localhost' IDENTIFIED BY 'password';
# 分配权限
grant create,alter,select,insert,update,delete on *.* to vincent@localhost IDENTIFIED BY 'password';

# 收回权限
revoke create,alter,select,insert,update,delete on mysql.* from 'vincent'@'localhost';
# 刷新系统权限
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 常见错误&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Access denied for user ‘root@localhost’ (using password:NO)&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; systemctl stop mariadb.service
&amp;gt; mysqld_safe --skip-grant-tables &amp;amp;
# 可以不用密码进入MySQL
&amp;gt; mysql
&amp;gt; use mysql;
&amp;gt; truncate table user;
&amp;gt; flush privileges;

&amp;gt; grant all privileges on *.* to root@localhost identified by 'YourNewPassword' with grant option;


&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;p---php&quot;&gt;P - PHP&lt;/h2&gt;

&lt;p&gt;我自己使用到PHP的地方一般也只是用它来使用 &lt;strong&gt;PHPMyAdmin&lt;/strong&gt;，而web服务也是用 Java或者Python开发的，所以PHP用得比较少。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;安装&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 需要重启一下Apache服务&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service httpd restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试一下是否安装好&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vi /var/www/html/info.php

输入 i 进行插入

# &amp;lt;?php phpinfo(); ?&amp;gt;

ESC -&amp;gt; 英文冒号 -&amp;gt; wq 保存退出
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后再浏览器地址中输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;ip地址/info.php&lt;/code&gt;，这时应该能看到到当前的 php信息。&lt;/p&gt;

&lt;h4 id=&quot;php--mysql&quot;&gt;关联 PHP 和 MySQL&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install php-mysql php-gd php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完后重启 Apache&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl restart httpd.service
或者
service httpd restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在 info.php 中就能看到mysql的模块。&lt;/p&gt;

&lt;h4 id=&quot;phpmyadmin&quot;&gt;安装 phpMyadmin&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install phpMyAdmin php-mcrypt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完后会在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/share&lt;/code&gt; 目录下有个 &lt;strong&gt;phpMydmin&lt;/strong&gt;目录，将该目录拷贝的 html 目录下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cd /usr/share
# cp -a phpMyAdmin/ /var/www/html/phpmyadmin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h6 id=&quot;section-5&quot;&gt;一些错误&lt;/h6&gt;

&lt;p&gt;The mbstring extension is missing. Please check your PHP configuration.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vi /etc/php.ini
	
在 [PHP] 下面插入
	
# extension=php_mbstring.dll
   
* 重启 httpd.service
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You don’t have permission to access /phpmyadmin/ on this server.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi /etc/httpd/conf.d/phpMyAdmin.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/img/p-centos-lnmp/phpmyadmin-permission.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;n---nginx&quot;&gt;N - Nginx&lt;/h2&gt;

&lt;h4 id=&quot;apache-nginx&quot;&gt;有了Apache为什么要使用 Nginx&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;http://willis.blog.51cto.com/11907152/1852083&quot;&gt;Apache, Tomcat, Nginx的区别&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apache 和 Nginx 都叫做 [&lt;em&gt;HTTP Server&lt;/em&gt;]，Tomcat这一类的则是 [&lt;em&gt;Application Server&lt;/em&gt;]。&lt;/p&gt;

&lt;p&gt;Nginx 相对于Apache而言，具有&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;安装&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 启动 Nginx 。注意，Apache和Nginx默认都是监听的80端口，所以注意端口占用，要么修改默认的端口。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 停止nginx&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx -s stop
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 重启nginx&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;nginx 相关配置文件路径 ：&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/nginx/nginx.conf&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;r---redis&quot;&gt;R - Redis&lt;/h2&gt;

&lt;p&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum install -y redis
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 启动&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl start redis
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 开机启动&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl enable redis
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt; 停止&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;systemctl stop redis
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;f---ftp&quot;&gt;F - FTP&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;vsftpd&lt;/strong&gt; 是Linux 下比较著名的FTP服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum -y install vsftpd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;相关操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# systemctl start vsftpd     # 启动 vsftpd
# systemctl enable vsftpd		# 设置开机启动
# systemctl stop vsftpd		# 停止 vsftpd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;修改配置文件&lt;/h4&gt;

&lt;p&gt;打开 &lt;strong&gt;/etc/vsftpd/vsftpd.conf&lt;/strong&gt;，修改配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;anonymous_enable=NO 	#设定不允许匿名访问
local_enable=YES 			#设定本地用户可以访问。注：如使用虚拟宿主用户，在该项目设定为NO的情况下所有虚拟用户将无法访问
ascii_upload_enable=YES
ascii_download_enable=YES #设定支持ASCII模式的上传和下载功能
chroot_list_enable=YES 	#使用户不能离开主目录
pam_service_name=vsftpd   #PAM认证文件名。PAM将根据/etc/pam.d/vsftpd进行认证
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以下这些是关于vsftpd虚拟用户支持的重要配置项，默认vsftpd.conf中不包含这些设定项目，需要自己手动添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;guest_enable=YES			#设定启用虚拟用户功能
guest_username=ftp		#指定虚拟用户的宿主用户，CentOS中已经有内置的ftp用户了
user_config_dir=/etc/vsftpd/vuser_conf #设定虚拟用户个人vsftp的CentOS FTP服务文件存放路径。存放虚拟用户个性的CentOS FTP服务文件(配置文件名=虚拟用户名
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;添加用户&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;useradd vicnent 	# 添加一个用户
passwd vincent		# 给用户设置密码
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/home&lt;/code&gt; 路径下，就会多出一个 &lt;strong&gt;vincent&lt;/strong&gt; 的文件夹。&lt;/p&gt;

&lt;p&gt;然后就可以在其他电脑上通过FileZilla这类的FTP软件进行上传下载文件了。但是要注意文件的权限。&lt;/p&gt;

</description>
        <pubDate>Fri, 31 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/03/31/centos-lamp/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/31/centos-lamp/</guid>
        
        <category>Web服务器</category>
        
        
      </item>
    
      <item>
        <title>Web服务器压力测试工具 - webbench,Siege</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Webbench是有名的网站压力测试工具，它是由 Lionbridge公司开发。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为之前公司网站的服务器各种拒绝连接，想要测试一下网站的QPS(每秒查询率)，看下大概能到多少并发，于是找到这个工具。但是结果果然超乎想象，2333…&lt;/p&gt;

&lt;h2 id=&quot;webbench&quot;&gt;Webbench&lt;/h2&gt;

&lt;p&gt;webbench是有名的网站压力测试工具，最多可以模拟3万个并发连接去测试网站的负载能力。&lt;/p&gt;

&lt;p&gt;webbench能测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。&lt;/p&gt;

&lt;p&gt;webbench的标准测试可以向我们展示服务器的两项内容：每秒钟相应请求数和每秒钟传输数据量。&lt;/p&gt;

&lt;h4 id=&quot;mac&quot;&gt;MAC安装&lt;/h4&gt;

&lt;p&gt;在Mac环境下，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;brew&lt;/code&gt;进行安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install ctags # 依赖安装

wget http://blog.zyan.cc/soft/linux/webbench/webbench-1.5.tar.gz

tar -zxvf webbench-1.5.tar.gz

cd webbench-1.5

sudo mkdir -pv /usr/local/man/man1 # 创建文件夹

sudo make &amp;amp;&amp;amp; sudo make install # 安装

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section&quot;&gt;使用&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;webbench -c 100 -t 30 [URL]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数说明：&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt;表示并发数，&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt;表示时间(秒)&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;相关命令&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
webbench [option]... URL

  -f|--force               压测时不等待服务端返回
  -r|--reload              Send reload request - Pragma: no-cache.
  -t|--time &amp;lt;sec&amp;gt;          压测时间/s, 默认30/s
  -p|--proxy &amp;lt;server:port&amp;gt; 使用代理来进行请求
  -c|--clients &amp;lt;n&amp;gt;         并发数量默认1个
  -9|--http09              使用HTTP/0.9 协议请求
  -1|--http10              使用HTTP/1.0 协议请求
  -2|--http11              使用HTTP/1.1 协议请求
  --get                    使用GET方式请求
  --head                   使用 HEAD 方式请求
  --options                Use OPTIONS request method.
  --trace                  Use TRACE request method.
  -?|-h|--help             This information.
  -V|--version             显示当前版本

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;使用结果&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/p-web-test-tool/webbench-result.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;貌似只有 0 failed 访问才不会有太大影响。其他或多或少都会有影响。 神经病的马赛克。~&lt;/p&gt;

&lt;h2 id=&quot;siege&quot;&gt;Siege&lt;/h2&gt;

&lt;p&gt;一款开源的压力测试工具，可以根据配置对一个WEB站点进行多用户的并发访问，记录每个用户所有请求过程的相应时间，并在一定数量的并发访问下重复进行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最新版本：&lt;a href=&quot;http://download.joedog.org/siege/siege-latest.tar.gz&quot;&gt;http://download.joedog.org/siege/siege-latest.tar.gz&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;源代码：&lt;a href=&quot;https://github.com/JoeDog/siege.git&quot;&gt;https://github.com/JoeDog/siege.git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;mac-&quot;&gt;mac 安装&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# wget http://download.joedog.org/siege/siege-latest.tar.gz
# tar -zxvf siege-latest.tar.gz
# cd siege-latest/
# ./configure
# make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;相关命令&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-V, --version             VERSION, prints the version number.
  -h, --help                HELP, prints this section.
  -C, --config              CONFIGURATION, show the current config.
  -v, --verbose             VERBOSE, prints notification to screen.
  -q, --quiet               QUIET turns verbose off and suppresses output.
  -g, --get                 GET, pull down HTTP headers and display the
                            transaction. Great for application debugging.
  -c, --concurrent=NUM      CONCURRENT users, default is 10
  -i, --internet            INTERNET user simulation, hits URLs randomly.
  -b, --benchmark           BENCHMARK: no delays between requests.
  -t, --time=NUMm           TIMED testing where &quot;m&quot; is modifier S, M, or H
                            ex: --time=1H, one hour test.
  -r, --reps=NUM            REPS, number of times to run the test.
  -f, --file=FILE           FILE, select a specific URLS FILE.
  -R, --rc=FILE             RC, specify an siegerc file
  -l, --log[=FILE]          LOG to FILE. If FILE is not specified, the
                            default is used: PREFIX/var/siege.log
  -m, --mark=&quot;text&quot;         MARK, mark the log file with a string.
  -d, --delay=NUM           Time DELAY, random delay before each requst
                            between .001 and NUM. (NOT COUNTED IN STATS)
  -H, --header=&quot;text&quot;       Add a header to request (can be many)
  -A, --user-agent=&quot;text&quot;   Sets User-Agent in request
  -T, --content-type=&quot;text&quot; Sets Content-Type in request
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;使用&lt;/h4&gt;

&lt;p&gt;100个并发访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.baidu.com&lt;/code&gt;，并重复20次&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;siege -c 100 -r 20 http://www.baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 urls.txt 中列出所有网址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;siege -c 100 -r 20 -f urls.txt  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;随机选取 urls.txt 中列出的网址&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;siege -c 100 -r 20 -f urls.txt -i
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不等待返回结果,100个并发随机选取urls.txt重复请求20个&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;siege -c 2000 -r 100 -f urls.txt -i -b  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;»&lt;/strong&gt; 指定 http 请求头请求&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;siege -H &quot;Content-Type:application/json&quot; -c 100 -r 20 -f urls.txt -i -b  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;»&lt;/strong&gt; POST 请求&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;siege -c 100 -r 20 http://www.baidu.com/ POST p1=v1&amp;amp;p2=v2  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;siege-&quot;&gt;Siege 输出结果说明&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/p-web-test-tool/siege-result.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Transactions&lt;/td&gt;
      &lt;td&gt;总共测试次数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Availability&lt;/td&gt;
      &lt;td&gt;成功次数百分比&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Elapsed time&lt;/td&gt;
      &lt;td&gt;总共耗时多少秒&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Data transferred&lt;/td&gt;
      &lt;td&gt;总共数据传输&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Response time&lt;/td&gt;
      &lt;td&gt;等到响应耗时&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Transaction rate&lt;/td&gt;
      &lt;td&gt;平均每秒处理请求数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Throughput&lt;/td&gt;
      &lt;td&gt;吞吐率&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Concurrency&lt;/td&gt;
      &lt;td&gt;最高并发&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Successful transactions&lt;/td&gt;
      &lt;td&gt;成功的请求数&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Failed transactions&lt;/td&gt;
      &lt;td&gt;失败的请求数&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;end&quot;&gt;END&lt;/h2&gt;

&lt;p&gt;性能测试工具目前最常见的有以下几种：&lt;code class=&quot;highlighter-rouge&quot;&gt;ab&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;webbench&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;http_load&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;siege&lt;/code&gt;，后面有用到再来试试。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.open-open.com/news/view/d6dff4&quot;&gt;Webbench 一款 Linux 下的压力测试工具 for Mac&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.skyf.org/webbench-web-test-tools/&quot;&gt;记录：Web服务器压力测试工具WebBench、Siege&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 28 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/03/28/web-pressure-test/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/28/web-pressure-test/</guid>
        
        <category>Web服务器</category>
        
        
      </item>
    
      <item>
        <title>阿里云DNS动态解析</title>
        <description>&lt;p&gt;想要通过域名直接访问路由器的公网IP，但是路由器的外网IP不是固定的，每次重启路由器都会改变。于是想要实现阿里云的DDNS(动态解析)。&lt;/p&gt;

&lt;p&gt;好在阿里云提供了 SDK 可供我们使用，这里使用python来操作。&lt;a href=&quot;https://develop.aliyun.com/sdk/python?spm=5176.7926450.210367.2.Xov5Bp&quot;&gt;python-sdk&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;准备&lt;/h2&gt;

&lt;h4 id=&quot;python-sdk&quot;&gt;安装 python sdk&lt;/h4&gt;
&lt;p&gt;首先需要在当前机器上安装阿里云的 python SDK&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install aliyun-python-sdk-alidns
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为这里只需要使用它的 dns 功能，需要其他的功能可以查看 &lt;a href=&quot;https://help.aliyun.com/document_detail/30003.html&quot;&gt;阿里云 python-sdk 列表&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;access-key&quot;&gt;Access Key&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://ak-console.aliyun.com/#/accesskey&quot;&gt;Access Key管理&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Access Key ID&lt;/li&gt;
  &lt;li&gt;Access Key Secret&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-1&quot;&gt;添加一条域名解析&lt;/h4&gt;

&lt;p&gt;添加一条A记录，主机记录可以为你的二级域名，例如： &lt;code class=&quot;highlighter-rouge&quot;&gt;xx.vincents.cn&lt;/code&gt;。记录值随便写 &lt;code class=&quot;highlighter-rouge&quot;&gt;8.8.8.8&lt;/code&gt;，因为后面会根据实际的IP进行动态更改。&lt;/p&gt;

&lt;h2 id=&quot;python-sdk-1&quot;&gt;使用阿里云的 python SDK&lt;/h2&gt;

&lt;p&gt;通过脚本更新DNS记录需要几个关键的信息，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一级域名（你的域名）&lt;/li&gt;
  &lt;li&gt;主机记录（你的二级域名）&lt;/li&gt;
  &lt;li&gt;记录值 （你的机器的IP地址）&lt;/li&gt;
  &lt;li&gt;记录ID （这条解析记录的ID）&lt;/li&gt;
  &lt;li&gt;记录TTL （这条解析记录的生存时间）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;ip&quot;&gt;获取当前机器的IP&lt;/h4&gt;

&lt;p&gt;可以通过访问 &lt;a href=&quot;ip.cn&quot;&gt;ip.cn&lt;/a&gt;这个网站，获取本机的IP。
在终端中输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -s ip.cn
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vincents-iMac:~ vincent$ curl -s ip.cn
当前 IP：xx.xx.xxx.xxx 来自：重庆市 联通
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;python code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;&quot;&quot;
通过 ip.cn 获取当前主机的外网IP
&quot;&quot;&quot;
def get_my_publick_ip():
    get_ip_method = os.popen('curl -s ip.cn')
    get_ip_responses = get_ip_method.readlines()[0]
    get_ip_pattern = re.compile(r'\d+\.\d+\.\d+\.\d+')
    get_ip_value = get_ip_pattern.findall(get_ip_responses)
    return get_ip_value
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;id&quot;&gt;获取解析记录ID&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;&quot;&quot;
获取域名的解析信息
&quot;&quot;&quot;
def check_records(dns_domain):
    clt = client.AcsClient(access_key_id, access_key_secret, 'cn-hangzhou')
    request = DescribeDomainRecordsRequest.DescribeDomainRecordsRequest()
    request.set_DomainName(dns_domain)
    request.set_accept_format(rc_format)
    result = clt.do_action(request)
    result = json.JSONDecoder().decode(result)
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;id-1&quot;&gt;根据解析记录ID查询上一次的记录值&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;&quot;&quot;
根据域名解析记录ID查询上一次的IP记录
&quot;&quot;&quot;
def get_old_ip(record_id):
    clt = client.AcsClient(access_key_id,access_key_secret,'cn-hangzhou')
    request = DescribeDomainRecordInfoRequest.DescribeDomainRecordInfoRequest()
    request.set_RecordId(record_id)
    request.set_accept_format(rc_format)
    result = clt.do_action(request)
    result = json.JSONDecoder().decode(result)
    result = result['Value']
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;更新解析记录&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;&quot;&quot;
更新阿里云域名解析记录信息
&quot;&quot;&quot;
def update_dns(dns_rr, dns_type, dns_value, dns_record_id, dns_ttl, dns_format):
    clt = client.AcsClient(access_key_id, access_key_secret, 'cn-hangzhou')
    request = UpdateDomainRecordRequest.UpdateDomainRecordRequest()
    request.set_RR(dns_rr)
    request.set_Type(dns_type)
    request.set_Value(dns_value)
    request.set_RecordId(dns_record_id)
    request.set_TTL(dns_ttl)
    request.set_accept_format(dns_format)
    result = clt.do_action(request)
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;完整脚本&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/env python&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;json&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;os&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;re&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;aliyunsdkcore&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;aliyunsdkalidns.request.v20150109&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DescribeDomainRecordsRequest&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;aliyunsdkalidns.request.v20150109&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DescribeDomainRecordInfoRequest&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;aliyunsdkalidns.request.v20150109&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UpdateDomainRecordRequest&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 阿里云 Access Key ID&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;access_key_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxxxx&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 阿里云 Access Key Secret&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;access_key_secret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;xxxxxxxx&quot;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 阿里云 一级域名&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rc_domain&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'xxx.cn'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 返回内容格式&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rc_format&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'json'&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
获取域名的解析信息
&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;check_records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dns_domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;clt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AcsClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;access_key_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;access_key_secret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'cn-hangzhou'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DescribeDomainRecordsRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DescribeDomainRecordsRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_DomainName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dns_domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_accept_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
根据域名解析记录ID查询上一次的IP记录
&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_old_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;record_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;clt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AcsClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;access_key_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;access_key_secret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'cn-hangzhou'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DescribeDomainRecordInfoRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DescribeDomainRecordInfoRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_RecordId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;record_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_accept_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;JSONDecoder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Value'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
更新阿里云域名解析记录信息
&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;update_dns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dns_rr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dns_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dns_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dns_record_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dns_ttl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dns_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;clt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AcsClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;access_key_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;access_key_secret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'cn-hangzhou'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UpdateDomainRecordRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;UpdateDomainRecordRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_RR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dns_rr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_Type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dns_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_Value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dns_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_RecordId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dns_record_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_TTL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dns_ttl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_accept_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dns_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;&quot;&quot;
通过 ip.cn 获取当前主机的外网IP
&quot;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_my_publick_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get_ip_method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;popen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'curl -s ip.cn'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get_ip_responses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_ip_method&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readlines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get_ip_pattern&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r'&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d+&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d+'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;get_ip_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_ip_pattern&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_ip_responses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_ip_value&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write_to_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time_now&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strftime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Y-&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;m-&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;H:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;M:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;S'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;write_log&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'aliyun_ddns.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;write_log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_now&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# # 之前的解析记录&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;old_ip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;record_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dns_records&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;check_records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc_domain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dns_records&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;DomainRecords&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Record&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'A'&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RR&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'q'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;record_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;RecordId&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;q.vincents.cn recordID is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;record_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;old_ip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_old_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;record_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
               
    &lt;span class=&quot;n&quot;&gt;old_ip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_old_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;record_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# 获取主机当前的IP&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;now_ip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_my_publick_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;now host ip is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s, dns ip is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;s&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;old_ip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;The specified value of parameter Value is the same as old&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rc_rr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'q'&lt;/span&gt;                 &lt;span class=&quot;c&quot;&gt;# 解析记录&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rc_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt;               &lt;span class=&quot;c&quot;&gt;# 记录类型, DDNS填写A记录&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rc_value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;now_ip&lt;/span&gt;           &lt;span class=&quot;c&quot;&gt;# 新的解析记录值&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rc_record_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;record_id&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;# 记录ID&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rc_ttl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'1000'&lt;/span&gt;             &lt;span class=&quot;c&quot;&gt;# 解析记录有效生存时间TTL,单位:秒&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;update_dns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rc_rr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc_record_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc_ttl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc_format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;write_to_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;now_ip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;crontab-&quot;&gt;crontab 定时运行&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;crontab -e
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*/10 * * * * /usr/bin/python aliyun_ddns.py /dev/null 1&amp;gt;/dev/null
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中脚本存放路径替换为自己的实际路径&lt;/p&gt;

&lt;h4 id=&quot;crontab--1&quot;&gt;** crontab 定时重启服务器&lt;/h4&gt;

&lt;p&gt;由于个人使用的服务器配置一般都不高，重启服务器又能释放一些占用的内存。所以在凌晨定时重启服务器还是很有必要的。亲测，自己1G的内存，使用一段时间省了100M左右的内存可以使用，重启后，又变成600M多了。2333…&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;crontab -e
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 凌晨5点重启一次服务器
0 5 * * * /sbin/reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看系统重启记录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;last reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/img/p-aliyun-ddns/reboot_result.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考学习&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://enginx.cn/2016/08/22/%E9%80%9A%E8%BF%87python%E5%B0%86%E9%98%BF%E9%87%8C%E4%BA%91dns%E8%A7%A3%E6%9E%90%E4%BD%9C%E4%B8%BAddns%E4%BD%BF%E7%94%A8.html&quot;&gt;通过python将阿里云DNS解析作为DDNS使用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.v2ex.com/t/249694&quot;&gt;通过阿里云域名动态解析 IP 地址&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 27 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/03/27/aliyun-ddns/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/27/aliyun-ddns/</guid>
        
        <category>Python</category>
        
        
      </item>
    
      <item>
        <title>iOS 多线程和线程锁</title>
        <description>&lt;p&gt;在 &lt;strong&gt;ibireme&lt;/strong&gt; 的 &lt;a href=&quot;https://bestswifter.com/ios-lock/&quot;&gt;不再安全的 OSSpinLock&lt;/a&gt; 一文中，有一张图简单比较了各种所的加锁性能
&lt;img src=&quot;/img/p-ios-lock/lock_benchmark.png&quot; alt=&quot;&quot; /&gt;
下面根据顺序分析每个加锁的实现原理。注意：加解锁速度并不表示锁的效率，只表示加解锁的操作在执行时的复杂度。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;锁之间的关系&lt;/h2&gt;

&lt;h4 id=&quot;section-1&quot;&gt;忙等类&lt;/h4&gt;

&lt;p&gt;test_and_set -&amp;gt; OSSpinLock -&amp;gt; os_unfair_lock&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;休眠类&lt;/h4&gt;

&lt;h5 id=&quot;lllfutexwait---gcd&quot;&gt;lll_futex_wait -&amp;gt; GCD信号量&lt;/h5&gt;

&lt;h5 id=&quot;lllfutexwait---pthreadmutex&quot;&gt;lll_futex_wait -&amp;gt; pthread_mutex&lt;/h5&gt;
&lt;p&gt;1.加上错误处理 -&amp;gt; NSLock&lt;/p&gt;

&lt;p&gt;2.加上条件判断 -&amp;gt; NSCondition + Value -&amp;gt; NSConditionLock&lt;/p&gt;

&lt;p&gt;3.加上递归特性 -&amp;gt; NSRecursiveLock&lt;/p&gt;

&lt;p&gt;4.加上递归特性、哈希特性 -&amp;gt; @Synchronized(Obj)&lt;/p&gt;

&lt;h2 id=&quot;osspinlock-&quot;&gt;OSSpinLock 自旋锁&lt;/h2&gt;

&lt;h4 id=&quot;section-3&quot;&gt;自旋锁原理&lt;/h4&gt;

&lt;p&gt;自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bool lock = false; // 一开始没有锁上，任何线程都可以申请锁  
do {  
    while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁
    lock = true; // 挂上锁，这样别的线程就无法获得锁
        Critical section  // 临界区
    lock = false; // 相当于释放锁，这样别的线程可以进入临界区
        Reminder section // 不需要锁保护的代码        
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;osspinlock&quot;&gt;OSSpinLock&lt;/h4&gt;

&lt;p&gt;忙等锁，会消耗大量的CPU资源。不适合较长时间的任务，因为会导致其他线程忙等。&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// OSSpinLock
#import &amp;lt;libkern/OSAtomic.h&amp;gt;

// 自旋锁
- (void)testOSSpinLock {
    __block OSSpinLock osLock = OS_SPINLOCK_INIT;
    
    // 线程1
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        NSLog(@&quot;线程1 准备上锁&quot;);
        OSSpinLockLock(&amp;amp;osLock);
        NSLog(@&quot;线程1&quot;);
        OSSpinLockUnlock(&amp;amp;osLock);
        NSLog(@&quot;线程1 解锁完成&quot;);
    });
    
    // 线程2
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^{
        NSLog(@&quot;线程2 准备上锁&quot;);
        OSSpinLockLock(&amp;amp;osLock);
        NSLog(@&quot;线程2&quot;);
        OSSpinLockUnlock(&amp;amp;osLock);
        NSLog(@&quot;线程2 解锁完成&quot;);
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;参考学习中的连接已经说明 OSSpinLock 其实已经不再安全。主要原因在于&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当低优先级线程拿到锁时，高优先级线程进入忙等(budy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;优先级反转&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而且，实际上苹果在&lt;code class=&quot;highlighter-rouge&quot;&gt;iOS10&lt;/code&gt;中也不再推荐使用 OSSpinLock,转而使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;os_unfair_lock()&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;osunfairlock&quot;&gt;os_unfair_lock&lt;/h2&gt;

&lt;p&gt;iOS 10.+ 之后添加的，也是属于忙等锁。&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// os_unfair_lock
#import &amp;lt;os/lock.h&amp;gt;

os_unfair_lock_t unfairlock = &amp;amp;(OS_UNFAIR_LOCK_INIT);

os_unfair_lock_lock(unfairlock);
NSLog(@&quot;os_unfair_lock 执行&quot;);
os_unfair_lock_unlock(unfairlock);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;dispatchsemaphore-gcd&quot;&gt;dispatch_semaphore GCD信号量&lt;/h2&gt;

&lt;p&gt;加锁时会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，立刻执行。在没有等待的情况下，性能比 pthread_mutex 高，但是一旦有等待的情况出现，性能就会急剧下降。其优势在于等待时不会消耗 CPU 资源，会进行线程休眠。&lt;/p&gt;

&lt;p&gt;然而，主动让出时间片(线程休眠)并不总是代表效率高，让出时间片会导致操作系统切换到另一个线程，这类上线文切换一般需要10ms左右，且至少需要两次切换才能切换回本线程。如果小于20ms，忙等就比线程睡眠更加高效了。&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 信号量
- (void)testDispatch_semaphore {
    dispatch_semaphore_t signal = dispatch_semaphore_create(1);
    dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 3.0f * NSEC_PER_SEC);
    // DISPATCH_TIME_FOREVER 不限时
    
    // 线程1
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;线程1 等待ing&quot;);
        dispatch_semaphore_wait(signal, timeout);   // signal 值 - 1
        sleep(2);
        NSLog(@&quot;线程1&quot;);
        dispatch_semaphore_signal(signal);          // signal 值 + 1
        NSLog(@&quot;线程1 发送信号&quot;);
    });
    
    // 线程2
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;线程2 等待ing&quot;);
        dispatch_semaphore_wait(signal, timeout);   // signal 值 - 1
        NSLog(@&quot;线程2 sleep&quot;);
        sleep(2);
        NSLog(@&quot;线程2&quot;);
        dispatch_semaphore_signal(signal);          // signal 值 + 1
        NSLog(@&quot;线程2 发送信号&quot;);
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;pthreadmutex--&quot;&gt;pthread_mutex  互斥锁&lt;/h2&gt;

&lt;p&gt;pthread 表示 POSIX thread，定义了一组跨平台的线程相关的API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上线文切换。&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// pthread
#import &amp;lt;pthread.h&amp;gt;

// pthread_mutex 互斥锁
- (void)testPthread_mutex {
    static pthread_mutex_t pLock;
    pthread_mutex_init(&amp;amp;pLock, NULL);
    
    // 线程1
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;线程1 准备上锁&quot;);
        pthread_mutex_lock(&amp;amp;pLock);
        NSLog(@&quot;线程1&quot;);
        sleep(3);
        pthread_mutex_unlock(&amp;amp;pLock);
        NSLog(@&quot;线程1 释放锁&quot;);
    });
    
    // 线程2
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        NSLog(@&quot;线程2 准备上锁&quot;);
        pthread_mutex_lock(&amp;amp;pLock);
        NSLog(@&quot;线程2&quot;);
        pthread_mutex_unlock(&amp;amp;pLock);
        NSLog(@&quot;线程2 释放锁&quot;);
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;\/&lt;/strong&gt; 一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或者释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。&lt;/p&gt;

&lt;p&gt;然而这种情况会经常发生，比如某个函数申请了锁，在临界区内又递归调用了自己。幸运的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt; 支持递归锁，也就是允许一个线程递归的申请锁。&lt;/p&gt;

&lt;h4 id=&quot;pthreadmutex-&quot;&gt;pthread_mutex 递归锁&lt;/h4&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// pthread_mutex 递归锁
- (void)testPthread_mutex_recursive {
    static pthread_mutex_t pLock;
    // 定义锁的属性
    pthread_mutexattr_t attr;
    pthread_mutexattr_init(&amp;amp;attr);
    pthread_mutexattr_settype(&amp;amp;attr, PTHREAD_MUTEX_RECURSIVE); // 设置为递归锁
    
    pthread_mutex_init(&amp;amp;pLock, &amp;amp;attr);
    pthread_mutexattr_destroy(&amp;amp;attr);
    
    // 线程1
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        static void (^RecursiveBlock)(int);
        RecursiveBlock = ^(int value) {
            pthread_mutex_lock(&amp;amp;pLock);
            if (value &amp;gt; 0) {
                NSLog(@&quot;value: %d&quot;, value);
                sleep(1);
                RecursiveBlock(value - 1);
            }
        };
        
        NSLog(@&quot;线程1 准备上锁&quot;);
        RecursiveBlock(5);
        NSLog(@&quot;线程1&quot;);
        pthread_mutex_unlock(&amp;amp;pLock);
        NSLog(@&quot;线程1 解锁&quot;);
    });
    
    // 线程2
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;线程2 准备上锁&quot;);
        pthread_mutex_lock(&amp;amp;pLock);
        NSLog(@&quot;线程2&quot;);
        pthread_mutex_unlock(&amp;amp;pLock);
        NSLog(@&quot;线程2 解锁&quot;);
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;递归锁比较安全，可以认为同一线程加且仅加一次锁，重复加锁不会造成死锁。无论同一线程加锁多少次，解锁1次即可。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;互斥锁的实现&lt;/h4&gt;

&lt;p&gt;互斥锁在申请锁时，调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex_lock&lt;/code&gt;方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到&lt;code class=&quot;highlighter-rouge&quot;&gt;lll_futex_wait&lt;/code&gt;函数，从而导致线程休眠。&lt;/p&gt;

&lt;p&gt;上面提到说，如果线程等待的临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如1000次)的test and set，这样可以在错误使用互斥锁时提高性能。&lt;/p&gt;

&lt;p&gt;另外，由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt;有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。&lt;/p&gt;

&lt;h2 id=&quot;nslock--nsrecursivelock&quot;&gt;NSLock 和 NSRecursiveLock&lt;/h2&gt;

&lt;p&gt;NSLock /NSRecursiveLock  是 Objective-c 以对象的形式暴露给开发者的一种锁。&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// NSLock
- (void)testNSLock {
    NSLock *lock = [NSLock new];
    [lock lock];
    NSLog(@&quot;加锁运行&quot;);
    [lock unlock];
    
    NSRecursiveLock *recursiveLock = [NSRecursiveLock new];
    [recursiveLock lock];
    NSLog(@&quot;加锁运行&quot;);
    [recursiveLock unlock];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的 NSLock 和 NSRecursiveLock 都是封装的互斥锁 &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_mutex&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;NSLock 只是在内部封装了一个 pthread_mutex，属性为 &lt;code class=&quot;highlighter-rouge&quot;&gt;PTHREAD_MUTEX_ERRORCHECK&lt;/code&gt;，他会损失一定的性能换来错误提示。理论上来说，NSLock 和 pthread_mutex 拥有相同的运行效率，实际由于封装的原因会略慢一点。由于有缓存存在，相差不会很多。&lt;/p&gt;

&lt;p&gt;NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，NSRecursiveLock 的类型为 PTHREAD_MUTEX_RECURSIVE。&lt;/p&gt;

&lt;h2 id=&quot;nscondition&quot;&gt;NSCondition&lt;/h2&gt;

&lt;p&gt;它通常用于表明共享资源是佛偶可被访问或者确保一系列任务能按照指定的执行顺序执行。如果一个线程视图访问一个共享资源，而正在访问该资源的线程将其条件设置为不可访问，那么该线程会被阻塞，知道正在访问该资源的线程将访问条件更改为可访问状态或者说给被阻塞的线程发送信号后，被阻塞的线程才能正常访问这个资源。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt; 的底层是通过条件变量(condition variable) &lt;code class=&quot;highlighter-rouge&quot;&gt;pthread_cond_t&lt;/code&gt; 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，隐藏可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程。比如常见的  生产者–消费者模式。&lt;/p&gt;

&lt;h4 id=&quot;nsconditionlock&quot;&gt;NSConditionLock&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NSConditionLock&lt;/code&gt; 借助 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt; 来实现，它的本质就是个【生产者–消费者】模型。’条件被满足’可以理解为生产者提供了新的内容。&lt;code class=&quot;highlighter-rouge&quot;&gt;NSConditionLock&lt;/code&gt; 的内部持有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;NSCondition&lt;/code&gt; 对象，以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;_condition_value&lt;/code&gt; 属性。&lt;/p&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// NSConditionLock
- (void)testNSConditionLock {
    NSConditionLock *cLock = [[NSConditionLock alloc] initWithCondition:0];
    
    // 线程1
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        NSLog(@&quot;线程1 加锁&quot;);
        [cLock lockWhenCondition:1];
        NSLog(@&quot;线程1&quot;);
        [cLock unlockWithCondition:3];
        NSLog(@&quot;线程1 解锁&quot;);
    });
    
    // 线程2
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{
        NSLog(@&quot;线程2 加锁&quot;);
        if ([cLock tryLockWhenCondition:0]) {
            NSLog(@&quot;线程2&quot;);
            [cLock unlockWithCondition:1];
            NSLog(@&quot;线程2 解锁&quot;);
        } else {
            NSLog(@&quot;失败&quot;);
        }
    });
    
    // 线程3
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        NSLog(@&quot;线程3 加锁&quot;);
        [cLock lockWhenCondition:3];
        NSLog(@&quot;线程3&quot;);
        [cLock unlockWithCondition:2];
        NSLog(@&quot;线程3 解锁&quot;);
    });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述代码会按照：线程2 &amp;gt; 线程1 &amp;gt; 线程3 的顺序执行。&lt;/p&gt;

&lt;h2 id=&quot;synchronized&quot;&gt;@synchronized&lt;/h2&gt;

&lt;p&gt;示例代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@synchronized (self) {
   NSLog(@&quot;加锁运行&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只要关键字中的对象一致，则多个线程会互斥等待程序运行完成。&lt;/p&gt;

&lt;p&gt;@synchronized 实际上是把修饰对象当做锁来使用。这是通过一个哈希表来实现的，OC在底层使用了一个互斥锁的数组（可以理解为锁池），通过对对象去哈希值来得到对应的互斥锁。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;一些多线程的基础知识&lt;/h2&gt;

&lt;h4 id=&quot;section-6&quot;&gt;时间片轮转调度算法&lt;/h4&gt;

&lt;p&gt;了解多线程加锁必须知道时间片轮转调度算法，才能深切理解其原理，性能瓶颈。&lt;/p&gt;

&lt;p&gt;现代操作系统在管理普通线程时，通常采用时间片轮转算法（Round Robin，简称RR）。每个线程会被分配一段时间片（quantum），通常在10-100毫秒左右。当线程用于属于自己的时间片以后，就会被系统挂起，放入等待队列中，知道下一次被分配时间片，如果线程在时间片结束前阻塞或者结束，则CPU当即进行切换。由于线程切换需要时间，如果时间片太短，会导致大量CPU时间浪费在切换上；而如果这个时间太长，会使得其他线程等待太久。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;原子操作&lt;/h4&gt;

&lt;p&gt;狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完（理论上拥有CPU时间片无限长）。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现，但一句高级语言的代码却不是原子的，因为它最终是由多条汇编语言完成，CPU在进行时间片切换时，大多都会在某条代码的执行过程中。
但在多核处理器下，则需要硬件支持，没了解过具体实现。&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;自旋锁和互斥锁&lt;/h4&gt;

&lt;p&gt;都属于CPU时间片算法下的实现保护共享资源的一种机制。都实现互斥操作，加锁后仅允许一个访问者。&lt;/p&gt;

&lt;p&gt;区别在于自旋锁不会是线程进入wait状态，而是通过轮询不停查看是否该自旋锁的持有者已经释放的锁；对应的，互斥锁在出现锁已经被占用的情况下会进入wait状态，CPU会当即切换时间片。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;自旋锁实现原理&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lock = 0;
do{
    while(test_and_set(&amp;amp;lock));
    临界区
    lock = 0;
    其余部分
} while(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;test_and_set用来保证条件判断的原子性操作，lock为旗标。
自旋锁的一大缺陷是会使得线程处于忙等状态。因为如果临界区执行时间过长，其它线程就会在当前整个时间片一直处于忙等状态，浪费大量CPU时间。所以，如果临界区时间很短，可以使用自旋锁，否则建议使用互斥锁。&lt;/p&gt;

&lt;h4 id=&quot;section-10&quot;&gt;互斥锁的实现原理&lt;/h4&gt;

&lt;p&gt;互斥锁在出现锁的争夺时，未获得锁的线程会主动让出时间片，阻塞线程并睡眠，需要进行上下文切换，CPU会切换其它线程继续操作。
主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。&lt;/p&gt;

&lt;h4 id=&quot;section-11&quot;&gt;信号量的实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int sem_wait (sem_t *sem) {  
  int *futex = (int *) sem;
  if (atomic_decrement_if_positive (futex) &amp;gt; 0)
    return 0;
  int err = lll_futex_wait (futex, 0);
    return -1;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;信号量和互斥锁类似，都是在获取锁失败后线程进入wait状态，CPU会切换时间片。
信号量在最终都是调用一个sem_wait方法，并原子性的判断信号量，如果对其-1后依然大于0，则直接返回，继续临界区操作，否则进入等待状态。&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;多线程中的常见术语名词&lt;/h2&gt;

&lt;h6 id=&quot;mutex&quot;&gt;互斥锁(mutex)&lt;/h6&gt;

&lt;p&gt;提供共享资源互斥访问的锁。一个互斥锁同一时间只能被一个线程拥有。视图获取一个已经被其他线程拥有的互斥锁，会把当前线程置于休眠状态，直到该锁被其他线程释放并让当前线程获取。&lt;/p&gt;

&lt;p&gt;####### 递归锁(recursive lock)&lt;/p&gt;

&lt;p&gt;可以被同一线程多次锁住的锁。&lt;/p&gt;

&lt;h6 id=&quot;semaphore&quot;&gt;信号量(semaphore)&lt;/h6&gt;

&lt;p&gt;一个受保护的变量，它限制共享资源的访问。互斥锁(mutexes)和条件(conditions)都是不同类型的信号量。&lt;/p&gt;

&lt;h6 id=&quot;condition&quot;&gt;条件(condition)&lt;/h6&gt;

&lt;p&gt;一个用来同步资源访问的结构。线程等待某一个条件来决定是否被允许继续运行，知道其他线程显示的给该条件发送信号&lt;/p&gt;

&lt;h6 id=&quot;critical-section&quot;&gt;临界区(critical section)&lt;/h6&gt;

&lt;p&gt;同一时间只能不被一个线程执行的代码。&lt;/p&gt;

&lt;h6 id=&quot;input-source&quot;&gt;输入源(input source)&lt;/h6&gt;

&lt;p&gt;一个线程的异步事件源。输入源可以是基于端口的或者手工触发，并且必须被附加到某一个线程的run loop上面。&lt;/p&gt;

&lt;h6 id=&quot;thread&quot;&gt;线程(thread)&lt;/h6&gt;

&lt;p&gt;进程里面的一个执行过程流。每个线程都有它自己的栈空间，但除此之外同一进程的其他线程共享内存。&lt;/p&gt;

&lt;h6 id=&quot;main-thread&quot;&gt;主线程(main thread)&lt;/h6&gt;

&lt;p&gt;当创建进程时一起创建的特定类型的线程。当程序的主线程退出，则程序即退出。&lt;/p&gt;

&lt;h6 id=&quot;join-thread&quot;&gt;可连接的线程(join thread)&lt;/h6&gt;

&lt;p&gt;退出时资源不会被立即回收的线程。可连接的线程在资源被回收之前必须被显示脱离或由其他线程连接。可连接线程提供了一个返回值给连接它的线程。&lt;/p&gt;

&lt;h6 id=&quot;operation-object&quot;&gt;操作对象(operation object)&lt;/h6&gt;

&lt;p&gt;NSOperation 类的示例。操作对象封装了和某一任务相关的代码到一个执行单元里面。&lt;/p&gt;

&lt;h6 id=&quot;operation-queue&quot;&gt;操作队列(operation queue)&lt;/h6&gt;

&lt;p&gt;NSOperationQueue 类的示例。操作队列管理操作对象的执行。&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;参考学习链接&lt;/h2&gt;

&lt;blockquote&gt;

  &lt;ol&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.chaisong.xyz/2017/02/06/2017-02-06/&quot;&gt;【iOS】从同步锁到多线程&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/&quot;&gt;深入理解iOS开发中的锁&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://bestswifter.com/ios-lock/&quot;&gt;不再安全的 OSSpinLock&lt;/a&gt;&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Tue, 14 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/03/14/ios-lock/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/14/ios-lock/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>SSH登录服务器自动发邮件</title>
        <description>&lt;h2 id=&quot;python-&quot;&gt;python 读取登录信息，并发送邮件&lt;/h2&gt;
&lt;p&gt;效果就是，每当有人通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt; 登录到阿里云服务器的时候就会将登录者的ip和登录时间发送一封邮箱到指定的邮箱里面。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;获取登录信息&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CentOS&lt;/code&gt; 中 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/log/wtmp&lt;/code&gt; 记录每个用户的登录IP，登录次数，持续时间等信息。
#### 使用 smtplib 发送邮件&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;注意 发送方邮箱的密码，不是账号的密码。而是开启 &lt;code class=&quot;highlighter-rouge&quot;&gt;SMTP&lt;/code&gt; 后获取的授权码&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;section-1&quot;&gt;代码如下&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#-*- coding:utf-8 -*-


import poplib,email
from email.header import decode_header
import smtplib
import time
import os,sys
import re

# 发送方邮箱服务器
smtp_server = 'smtp.163.com'
# 发送方显示名称
sender_nikename = 'vincent'
# 发送方邮箱
sender = '****@163.com'
# 发送方邮箱授权码(不是密码)
sender_password = '********'
# 接收方
receiver = '*****@**.com'

def sshuserinfo():
    tmpfile = os.popen(&quot;who /var/log/wtmp&quot;)
    count = 0
    userlist = []
    for line in tmpfile:
        count = count + 1
        userlist.append(line)
    pat = re.compile(r&quot;\((.*)\)&quot;)
    valuelist = []
    if count &amp;gt; 0:
        result = pat.search(userlist[count - 1])
        valuelist.append(count)
        ipaddress = result.group(1)
        valuelist.append(ipaddress)
        alist = re.split(&quot;\s+&quot;,userlist[len(userlist)-1])
        valuelist.append(alist[2])       #时间年月日

        valuelist.append(alist[3])       #时间时分

    return valuelist

def sendmail(val):
    mail_to = smtplib.SMTP(smtp_server, 25)
    mail_to.login(sender, sender_password)
    msg = &quot;From: &quot; + sender_nikename + &quot;&amp;lt;&quot; + sender + &quot;&quot;&quot;&amp;gt;
To: &amp;lt;&quot;&quot;&quot; + receiver + &quot;&amp;gt;&quot; + &quot;&quot;&quot;
Subject: [有人远程登录了服务器] - sshusers added

someone ssh your host ,the user info is:
&quot;&quot;&quot; + val[1] + &quot; &quot; + val[2] + &quot; &quot; + val[3]
    mail_to.sendmail(sender, receiver, msg)
    mail_to.close()

if __name__ == '__main__':
    old_count = 0
    while 1:
        time.sleep(5)
        val = sshuserinfo()
        if len(val) &amp;gt; 0:
            if val[0] &amp;gt; old_count:
                print &quot;add users&quot;
                sendmail(val)
                old_count = val[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;nohup-&quot;&gt;使用 nohup 后台执行&lt;/h2&gt;
&lt;p&gt;Linux 后台进程运行的方法有好几种，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;supervisor&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;screen&lt;/code&gt;等。这里使用&lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt;来简单使用&lt;/p&gt;

&lt;h4 id=&quot;nohup--1&quot;&gt;使用 nohup 命令&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@iZ949j21i58Z ssh]# nohup python ssh_monitor.py &amp;amp;
[1] 19852
[root@iZ949j21i58Z ssh]# nohup: 忽略输入并把输出追加到&quot;nohup.out&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 表示将程序放到后台执行，但是如果启动该程序的logout，则该进程随记终止&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt; 使用 nohup命令后，原程序的标准输出被自动改向到当前目录的nohup.out文件，起到了log的作用，实现完整的守护进程功能。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;nohup--2&quot;&gt;终止 nohup 执行&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@iZ949j21i58Z ssh]# ps -ef | grep ssh_monitor
root     19852 19781  0 11:03 pts/2    00:00:00 python ssh_monitor.py
root     19856 19781  0 11:03 pts/2    00:00:00 grep --color=auto ssh_monitor
[root@iZ949j21i58Z ssh]# kill 19852
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;linux-python&quot;&gt;关于Linux Python执行的进程&lt;/h2&gt;
&lt;p&gt;当用户启动一个进程的时候，这个进程是运行在前台，使用与相应控制终端相联系的标准输入输如，输出进行输入和输出。即时将进程的输入输出重定向，并将进程放在后台执行，进程仍然和当前前端设备有关系。正因为如此，在当前的登录会话结束时，控制终端设备将和登录进程相脱，那么系统就像所有与这个终端联系的进程发送&lt;code class=&quot;highlighter-rouge&quot;&gt;SIGHUP&lt;/code&gt;的信号，通知进程线路已经挂起了，如果程序没有接管这个信号的处理，那么缺省的反应是进程结束。&lt;/p&gt;

&lt;p&gt;因此普通的程序并不能真正脱离登录会话而运行进程，为了使得在系统登录后还可以正常执行，只有使用&lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt;这一类的来启动相应程序。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;守护进程&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nohup&lt;/code&gt;启动的程序在进程执行完毕就退出了，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;kill&lt;/code&gt; 掉相关进程。而一些常见的服务进程通常永久的运行在后台，不想屏幕输出结果。
在 Linux/Unix 中这些永久的后台进程称为&lt;code class=&quot;highlighter-rouge&quot;&gt;守护进程（daemon）&lt;/code&gt;。守护进程通常从系统启动时自动开始执行，系统关闭时才停止。如果偶然某个守护进程消失了，那么它提供的服务将不再能被使用。&lt;/p&gt;

&lt;h4 id=&quot;centos-&quot;&gt;CentOS 常见的守护进程&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;硬件管理守护进程
apmd
apmd （Advanced Power Management）是高级电源管理。传统的电源管理标准，对于笔记本电脑比较有用，可以了解系统的电池电量信
息。并将相关信息通过 syslogd  写入日志。也可以用来在电源不足时关机。
acpid
acpid （Advanced Configuration and Power Interface ）是为替代传统的 APM  电源管理标准而推出的新型电源管理标准。通常笔记本电
脑需要启动电源进行管理。
alsasound Alsa 声卡驱动守护程序。 Alsa 和  OSS/Free 及  OSS/Linux 兼容，但是有自己的接口，甚至比OSS优秀。
cups cups(Common UNIX Printing System) 是通用UNIX打印守护进程，为Linux 提供第三代打印功能。
cups-config-
daemons
cups  打印系统切换守护进程。
cups-lpd cups  行打印守护进程。
lpd lpd  是老式打印守护程序，负责将 lpr  等程序提交给打印作业。
gpm
gpm（General Purpose Mouse Daemon  ）守护进程为文本模式下的 Linux  程序如 mc(Midnight Commander) 提供了鼠标的支持。它
也支持控制台下鼠标的拷贝，粘贴操作以及弹出式菜单。
irqbalance 对多个系统处理器环境下的系统中断请求进行负载平衡的守护程序。如果你只安装了一个CPU，就不需要加载这个守护程序。
kudzu
硬件自动检测程序，会自动检测硬件是否发生变动，并相应进行硬件的添加、删除工作。当系统启动时，kudzu会对当前的硬件进行检测，并
且和存储在 /etc/sysconfig/hwconf 中的硬件信息进行对照，如果某个硬件从系统中被添加或者删除时，那么 kudzu  就会察觉到，并且通知
用户是否进行相关配置，然后修改 /etc/sysconfig/hwconf ，使硬件资料与系统保持同步。如果 /etc/sysconfig/hwconf  这个文件不存在，
那么kudzu将会从 /etc/modprobe.conf 、/etc/sysconfig/network-scripts/ 和 /etc/X11/XF86Config  中探测已经存在的硬件。如果你
不打算增加新硬件，那么就可以关闭这个启动服务，以加快系统启动时间。
lm_seroems 检测主板工作情况守护进程。
mdmonitor RAID  相关设备的守护程序。
microcode_ctl 可编码以及发送新的微代码到内核以更新 Intel IA32  系列处理器守护进程。
pcmcia 主要用于支持笔记本电脑接口守护进程。
rawdevices 在使用集群文件系统时用于加载 raw  设备的守护进程。
smartd Self Monitor Analysis and Reporting Technology System，监控你的硬盘是否出现故障。

系统管理守护进程
atd at和batch 命令守护进程，用户用at命令调度的任务。batch 用于在系统负荷比较低时  运行批处理任务。
anacron
一个自动化运行任务守护进程。CentOS 随带四个自动化任务的工具：cron、 anacron 、at、和 batch。  当你的Linux 服务器并不是全天运
行，这个 anacron  就可以帮你执行在”crontab” 设定的时间内没有执行的工作。
crond cron  周期地运行用户  调度任务。
cpuspeed 监测系统空闲百分比，降低或加快CPU时钟速度和电压从而在系统空闲时将能源消耗降为最小，而在系统繁忙时最大化加快系统执行速度。
iiim 中文输入法服务器守护进程。

psacct 该守护进程包括几个工具用来监控进程活动的工具，包括ac,lastcomm, accton  和sa。
random 保存和恢复系统的高质量随机数生成器，这些随机数是系统一些随机行为提供的。
syslog 一个让系统引导时启动 syslog  和 klogd  系统日志守候进程的脚本。
xfs X Window 字型服务器守护进程，为本地和远程 X  服务器提供字型集。
yum-updatesd RPM 操作系统自动升级和软件包管理守护进程。
文件服务守护进程
amd 自动安装NFS守护进程。
atalk AppleTalk 网络守护进程。注意不要在后台运行该程序，该程序的数据结构必须在运行其他进程前先花一定时间初始化。
autofs 自动安装管理进程automount，与NFS相关，依赖于NIS服务器。
netdump 远程网络备份服务器守护进程。
diskdump 服务器磁盘备份守护进程。
portmap 该守护进程用来支持RPC连接，RPC 被用于 NFS  以及 NIS  等服务。
netfs Network Filesystem Mounter，该进程安装和卸载NFS、SAMBA和NCP网络文件系统。
nfs 网络文件系统守护进程。
nfslock NFS是一个流行的通过TCP/IP网络共享文件的协议，此守护进程提供了NFS文件锁定功能。
rsync remote sync  远程数据备份守护进程。

数据库管理守护进程
arptables_jf 为 arptables  网络的用户控制过滤的守护进程。
arpwatch 记录日志并构建一个在LAN 接口上看到的以太网地址和IP 地址对数据库。
bootparamd 引导参数服务器，为LAN 上的无盘工作站提供引导所需的相关信息。
ldap ldap（Lightweight Directory Access Protocol ）目录访问协议服务器守护进程。
mysqld 一个快速高效可靠的轻型  SQL   数据库引擎守护进程。
postgresql PostgreSQL  关系数据库引擎。
ypbind 为NIS（网络信息系统）客户机激活 ypbind 服务进程。
yppasswdd NIS口令服务器守护进程。
ypserv NIS 主服务器守护进程。

网络设备守护进程
bluetooch 蓝牙服务器守护进程。
netplugd
netplugd（network cable hotplug management daemon ）守护程序，用于监控一个或多个网络接口的状态，当某些事件触发时运行一个
外部脚本程序。
messagebus
D-BUS 是一个库，为两个或两个以上的应用程序提供一对一的通讯。 dbus-daemon-1  是一个应用程序，它使用这个库来实现 messagebus 守
护程序。多个应用程序通过连接 messagebus  守护程序可以实现与其他程序交换信息。
pppoe ADSL连接守护进程。
irda 红外端口守护进程。
isdn isdn启动和中止服务守护进程。
snmpd 本地简单网络管理守护进程。
network 激活/ 关闭启动时的各个网络接口守护进程。
iptables iptables 防火墙守护进程。

网络服务守护进程
chargen
使用 tcp 协议的 chargen server ，chargen（Character Generator Protocol）是一种网络服务，主要功能是提供类似远程打字
的功能。
chargen-udp 使用UDP协议的chargen server 。
dhcpd 动态主机控制协议(Dynamic Host Control Protocol)的服务守护进程。

daytime 使用TCP 协议的 Daytime 守护进程，该协议为客户机实现从远程服务器获取日期  和时间的功能。预设端口：13。
daytime-udp 使用 UDP  协议的 Daytime 守护进程。
time 该守护进程从远程主机获取时间和日期，采用TCP 协议。
time-udp 该守护进程从远程主机获取时间和日期，采用UDP协议。
dc_server 使用SSL 安全套接字的代理服务器守护进程。
dc_client 使用SSL 安全套接字的客户端守护进程。
echo 服务器回显客户数据服务守护进程。
echo-udp 使用UDP协议的服务器回显客户数据服务守护进程。
named DNS（BIND）服务器守护进程。
gated 网关路由守护进程。它支持各种路由协议，包括RIP版本1和2、DCN HELLO 协议、 OSPF 版本2以及EGP 版本2到4。
httpd Web服务器Apache 守护进程，可用来提供HTML文件以  及CGI 动态内容服务。
innd Usenet新闻服务器守护进程。
ntpd Network time Protocol daemon（网络时间校正协议）。ntpd是用来使系统和一个精确的时间源保持时间同步的协议守护进程。
proftpd proftpd  是Unix下的一个配置灵活的 ftp 服务器的守护程序。
readahead 、
readahead_early
readahead 和readahead_early 是在Fedora core 2中最新推出的两个后台运行的守护程序。其作用是在启动系统期间，将启动系
统所要用到的文件首先读取到内存中，然后在内存中进行执行，以加快系统的启动速度。
routed 该守护程序支持RIP协议的自动IP 路由表维护。RIP主要  使用在小型网络上，大一点的网络就需要复杂一点的协议。
rsh 远程主机上启动一个shell，并执行用户命令。
rwhod 允许远程用户获得运行rwho 守护程序的机器上所有已登录用户的列表。
rstatd 一个为LAN 上的其它机器收集和提供系统信息的守候进程。
ruserd 远程用户定位服务。  这是一个基于RPC的服务，它提供关于当前记录到 LAN  上一个机器日志中的用户信息
rwalld 远程用户消息发送服务。这是一项基于RPC的服务，允许用户给每个注册到 LAN  机器上的其他终端写消息。
rwhod rwhod  服务进程，它支持 LAN  的 rwho 和 ruptime  服务。
saslauthd 使用 SASL 的认证守护进程。
sendmail sendmail MTA 守护进程。
postfix postfix MTA 守护进程。
smb Samba  文件共享/ 打印服务守护进程。
squid 代理服务器squid 守护进程。
sshd OpenSSH  服务器守护进程。Secure Shell Protocol可以实现安全地远程管理主机。
tux 在Linux 内核中运行apache 服务器的守护进程。
vsftpd vsftpd 服务器的守护进程。
vncserver VNC （Virtual Network Computing ，虚拟网络计算），它提供了一种在本地系统上显示远程计算机整个” 桌面” 的轻量型协议。
inetd
因特网操作守护程序。监控网络对各种它管理的服务的需求，并在必要的时候启动相应的服务程序。在 Redhat  和 Mandrake  中被
xinetd 代替。Debian, Slackware, SuSE仍然使用。
xinetd 支持多种网络服务的超级服务器守护进程。
eklogin 使用 kerberos 5 加密的一种rlogin 会话鉴证守护进程。
gssftp 使用 kerberos 5 认证的 ftp 守护进程
krb5-telnet 使用 kerberos 5 认证的 telnet  守护进程。
klogin 使用 kerberos 5 认证远程登录守护进程。
kshell 使用 kerberos 5 认证的远程 Shell 守护进程。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Thu, 09 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/03/09/ssh-login/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/09/ssh-login/</guid>
        
        <category>Python</category>
        
        <category>CentOS</category>
        
        
      </item>
    
      <item>
        <title>非越狱iOS逆向微信</title>
        <description>&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;本文参考学习链接为： 
&lt;a href=&quot;https://github.com/buginux/WeChatRedEnvelop&quot;&gt;buginux&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;《 iOS 应用逆向工程》第二版&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;鉴于&lt;code class=&quot;highlighter-rouge&quot;&gt;《iOS逆向工程》&lt;/code&gt;这本书其实买了很久，但是又断断续续的荒废了。看到 &lt;a href=&quot;https://github.com/buginux/WeChatRedEnvelop&quot;&gt;buginux&lt;/a&gt; 写的这篇文章后，果断又尝试起来。
由于目前手上没有能越狱越狱的手机，打包尝试起来特别麻烦。好在最后还是完成了。上图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/reverse_wechat/result.jpg&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PS：目前最新的 6.5.5 版本红包并不能使用。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ipa&quot;&gt;1.获取砸壳后的微信ipa&lt;/h2&gt;
&lt;p&gt;有两种方法
1. 通过 &lt;a href=&quot;https://github.com/KJCracks/Clutch&quot;&gt;Clutch&lt;/a&gt; 对越狱手机上的应用砸壳
2. 直接在 PP助手上下载&lt;/p&gt;

&lt;p&gt;由于手里没有越狱的手机，所以就直接在 PP助手上下载了。
将下载后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;wechat.ipa&lt;/code&gt; 解压
&lt;code class=&quot;highlighter-rouge&quot;&gt;
$ unzip wechat.ipa -d wechat
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;class-dump-&quot;&gt;2.使用 class-dump 导出微信头文件&lt;/h2&gt;

&lt;h4 id=&quot;class-dump&quot;&gt;2.1 下载 class-dump&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ https://code.google.com/archive/p/networkpx/downloads
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;1.1 解压并拷入到 /usr/bin/&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tar -zxvf class-dump-z_0.2a.tar.gz
$ sudo cp mac_x86/class-dump-z /usr/bin/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;opendev-&quot;&gt;2.1.1 或者下载安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;OpenDev&lt;/code&gt; 环境。&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class-dump已经包含在openDev中,openDev 存放文件夹opt/IOSOpenDev/bin 中,

并在/Users/vincent/bash_profile 注册了系统变量 路径
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;h-&quot;&gt;2.2 导出 &lt;code class=&quot;highlighter-rouge&quot;&gt;.h&lt;/code&gt; 头文件&lt;/h4&gt;

&lt;p&gt;可执行文件位置在
&lt;code class=&quot;highlighter-rouge&quot;&gt;
~/wechat/Payload/WeChat.app/WeChat
&lt;/code&gt;
拷贝出来执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ class-dump
-H
WeChat
-o
heads
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;WeChat 是应用的可执行文件的路径&lt;/li&gt;
  &lt;li&gt;headers 是存放dump出来头文件的文件夹路径&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;dylib-&quot;&gt;3. 准备 dylib 动态链接库&lt;/h2&gt;
&lt;p&gt;将 &lt;a href=&quot;https://github.com/huanglins/WeChatRedEnvelop&quot;&gt;WeChatRedEnvelop&lt;/a&gt; clone 下来。执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; , dylib 文件在 &lt;code class=&quot;highlighter-rouge&quot;&gt;WeChatRedEnvelop/.theos/obj/debug/WeChatRedEnvelop.dylib&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git https://github.com/huanglins/WeChatRedEnvelop
$ cd WeChatRedEnvelop
make

$ cp .theos/obj/debug/WeChatRedEnvelop.dylib ~/Desktop # 注意是 .theos 目录，这是个隐藏目录
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section&quot;&gt;3.1 修改动态链接库依赖项&lt;/h4&gt;
&lt;p&gt;使用 macOS 自带的 &lt;code class=&quot;highlighter-rouge&quot;&gt;otool&lt;/code&gt; 工具检查 dylib 的依赖项&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ otool -L WeChatRedEnvelop.dylib

WeChatRedEnvelop2.dylib (architecture armv7):
	/Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)
	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)
	/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.13.0)
	/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.22.0)
	/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.6.21)
	/Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate (compatibility version 0.0.0, current version 0.0.0)
	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)
	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
WeChatRedEnvelop2.dylib (architecture arm64):
	/Library/MobileSubstrate/DynamicLibraries/WeChatRedEnvelop.dylib (compatibility version 0.0.0, current version 0.0.0)
	/usr/lib/libobjc.A.dylib (compatibility version 1.0.0, current version 228.0.0)
	/System/Library/Frameworks/Foundation.framework/Foundation (compatibility version 300.0.0, current version 1349.13.0)
	/System/Library/Frameworks/CoreFoundation.framework/CoreFoundation (compatibility version 150.0.0, current version 1348.22.0)
	/System/Library/Frameworks/UIKit.framework/UIKit (compatibility version 1.0.0, current version 3600.6.21)
	/Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate (compatibility version 0.0.0, current version 0.0.0)
	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 307.4.0)
	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate&lt;/code&gt; 链接地址到 &lt;code class=&quot;highlighter-rouge&quot;&gt;libsubstrate.dylib&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ install_name_tool -change /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate 
@loader_path/libsubstrate.dylib WeChatRedEnvelop.dylib
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;PS：libsubstrate.dylib 是越狱环境 MobileSubstrate 提供动态注入的一个链接库&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-1&quot;&gt;4 将动态链接库注入到二进制文件中&lt;/h2&gt;

&lt;h4 id=&quot;libsubstratedylib--wechatredenvelopdylib-wechatapp&quot;&gt;4.1 将 &lt;code class=&quot;highlighter-rouge&quot;&gt;libsubstrate.dylib&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;WeChatRedEnvelop.dylib&lt;/code&gt; 拷贝到WeChat.app中&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cp libsubstrate.dylib WeChatRedEnvelop.dylib wechat/Payload/WeChat.app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;optoolhttpsgithubcomalexzielenskioptool-&quot;&gt;4.2 使用开源的 &lt;a href=&quot;https://github.com/alexzielenski/optool&quot;&gt;optool&lt;/a&gt; 工具&lt;/h4&gt;
&lt;p&gt;编译安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;optool&lt;/code&gt; 工具&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 因为 optool 添加了 submodule，因为需要使用 --recuresive 选项，将子模块全部 clone 下来
$ git clone --recursive https://github.com/alexzielenski/optool.git
$ cd optool
$ xcodebuild -project optool.xcodeproj -configuration Release ARCHS=&quot;x86_64&quot; build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;optool-&quot;&gt;4.3 optool 注入&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ /path/to/optool install -c load -p &quot;@executable_path/WeChatRedEnvelop.dylib&quot; 
-t 
wechat/Payload/WeChat.app/WeChat
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-2&quot;&gt;5. 打包，重新签名&lt;/h2&gt;
&lt;p&gt;打包和重新签名可以直接使用图形化操作工具 &lt;a href=&quot;https://github.com/DanTheMan827/ios-app-signer&quot;&gt;ios-app-signer&lt;/a&gt; 来完成。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;需要使用开发者证书 ~~~~(&amp;gt;_&amp;lt;)~~~~&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/p-reverse_wechat/ios-app-signer.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击 start 后，指定保存路径，iOS App Signer 就会帮你搞定所有事情。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;6. 安装&lt;/h2&gt;
&lt;p&gt;使用 Xcode 菜单 - Window - Devices 中打开设置窗口 
&lt;img src=&quot;/img/reverse_wechat/xcode.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt;

</description>
        <pubDate>Fri, 03 Mar 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/03/03/reverse-wechat/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/03/03/reverse-wechat/</guid>
        
        <category>iOS</category>
        
        <category>逆向工程</category>
        
        
      </item>
    
      <item>
        <title>花样年华</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;如果我有多一张票，你会不会同我走。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/img/p-blossom_age/ba-shufa.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 05 Feb 2017 08:30:30 +0800</pubDate>
        <link>http://localhost:4000/2017/02/05/blossom-age/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/05/blossom-age/</guid>
        
        <category>旅行</category>
        
        
      </item>
    
      <item>
        <title>色达</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本次色达之行，由&lt;a href=&quot;http://www.sishuhw.com/&quot;&gt;私塾户外&lt;/a&gt;所组织&lt;/p&gt;

  &lt;p&gt;本文由&lt;a href=&quot;http://www.sishuhw.com/&quot;&gt;私塾户外&lt;/a&gt;的 [ 中静 ] 所写，也是我们的设计师和摄影师。赞一个！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://7xtctw.com2.z0.glb.clouddn.com/seda_002.jpg&quot; alt=&quot;色达-我&quot; /&gt;
那时年华静美,望穿了一川秋水,奈何,彼岸花开叶已碎,修成了陌路轮回,  &lt;br /&gt;
终是逃不过,逃不过那一眼初见里,彼此承诺,休说还说。    &lt;br /&gt;
我没有宗教信仰，怀着一颗并不虔诚的心一路翻山越岭而来，      &lt;br /&gt;
尘埃落定，洗尽铅华，初到色达便是如此感觉，也不知那些手持转经筒的僧侣在这蹉跎了多少个不食人间烟火的荏苒岁月？    &lt;br /&gt;
听一曲梵音，嗅一味藏香，那些繁华哀伤终成过往，白驹过隙，匆匆的铸成一抹哀伤，与之邂逅，终难忘。    &lt;br /&gt;
在这个位于四川西北最边远的角落，纵横的河曲蜿蜒之下，群山坑谷中叠起一片片起起落落的红辉，    &lt;br /&gt;
一路走来，沿途风雪日暖，花开花败，狂野不堪的风吹散了相聚与相散，     &lt;br /&gt;
立于山顶俯瞰，不仅自问，若今日离去，后会可有期？&lt;/p&gt;

&lt;p&gt;前往坛城，转经三回，耳旁皆是尘嚣，看前方佝偻的僧侣虔诚唱诵，似淹没在尘埃里的浮生，随着清风飘扬到了更远的地方。     &lt;br /&gt;
起伏延绵的山头上有墨色的秃鹫在上空盘旋，发出一声令人心悸的悲怆，   &lt;br /&gt;
即使这里有高原上最鼎盛的灯火，人间最圣洁的星光，却因为天葬，使这里的变得令人心生恐惧和离殇。    &lt;br /&gt;
一开始心里是抗拒的，我这种胆小如鼠的人是不应该去天葬这种地方观光，    &lt;br /&gt;
到最后却敌不过好奇心的驱使，一路跟着人群爬到了对面的山坡上，     &lt;br /&gt;
天葬开始时，烈日在一瞬间被乌云遮蔽，无数道刺骨的阴风肆掠而过，最后竟还伴随着雪花扬扬洒洒，   &lt;br /&gt;
那些被称之为“神之使者”的秃鹫乌泱直下，在天葬师把帘布掀开的一瞬间，疯狂啃食死者的遗骸，   &lt;br /&gt;
我们不约而同的掩面惊呼。    &lt;br /&gt;
然而此时身边却有一名陌生的藏家妇女双手紧握，嘴里急促的念唱着藏经，眼里含着我读不懂的泪。    &lt;br /&gt;
毫无征兆的，浓郁的尸臭突然随风散漫开来，我掩鼻仓惶而逃，这个在他们心目中被称之为最神圣的仪式，已足够让我铭记一生。&lt;/p&gt;

&lt;p&gt;寒意未尽，云潮涌动，太阳从乌云中探出，一如既往的照耀着它所庇佑了一生的大地。    &lt;br /&gt;
有多少人，被这俗世繁华迷醉了双眼，又有多少人，一袭素衣拂袖，怀揣丝丝执念，携款款深情扬言欲把红尘踏遍。     &lt;br /&gt;
轻触光阴的棱角，有喇嘛告诉我，他们不过是在这里解前世疑惑，还今生夙愿。    &lt;br /&gt;
这场旅行虽然路终没有走完，却未失落于那一处灯火阑珊。    &lt;br /&gt;
那日藏家孩童纯真的浅笑在无形中，于我的心间绽放出一世安冉，无限清欢，隐退了我所有的俗念。     &lt;br /&gt;
我依然是那个没有宗教信仰，特立独行的女子，    &lt;br /&gt;
然而我却在幽梦中悄悄种下一颗菩提，待它发芽生长触及我的傍晚和黎明，予我一伞庇佑，许我一世无争。    &lt;br /&gt;
夜慢慢深了，许是累了，许是倦了，合上双眼，隔一水轻柔，眸前煽动的仍是你淡然阔丽的容颜，    &lt;br /&gt;
我想要靠近，而你却无端远了，远了，终消失不见⋯⋯终散作云烟⋯⋯&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

</description>
        <pubDate>Tue, 03 May 2016 08:30:30 +0800</pubDate>
        <link>http://localhost:4000/2016/05/03/seda/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/05/03/seda/</guid>
        
        <category>旅行</category>
        
        
      </item>
    
  </channel>
</rss>
